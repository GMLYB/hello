# 面向对象知识（补）

#### == 和 equals()区别

* ==：运算符
  * 可以使用在基本数据类型变量和引用数据类型变量中
  * 如果比较的是 **基本数据类型** 变量：比较两个变量保存的数据是否相等
  * 如果比较的是 **引用数据类型** 变量：比较两个对象的地址值是否相等。即两个引用是否指向同一个对象实体
* equals()使用：
  * 是一个方法，不是运算符
  * 只能适用于引用数据类型
  * Object类中equals()的定义：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体
  * 像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用地址是否相同，而是比较两个对象的“实体内容”是否相同
  * 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的“实体内容”是否相同，那么，我们需要对Object类中的equals()进行重写

***

#### static关键字的使用

* **static：静态的** 
* **static可以用来修饰：属性、方法、代码块、内部类** 
* **使用static修饰属性：静态变量（或类变量）** 
  * 属性：是否使用了static修饰，又分为：**静态属性** 和 **非静态属性**（实例变量）
    * 实例变量：我们创建了类的多个对象，每个对象都会独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中相同的属性值的修改、
    * 静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过的。
  * static修饰属性的其他说明：
    * 静态变量随着类的加载而加载。我们可以通过 **“ 类.静态变量 ”** 的方式进行调用
    * 静态变量的加载要早于对象的创建
    * 由于类只会加载一次，则静态变量在内存中也只会存在一份，存在方法区的静态区域中
  * 静态属性举例：System.out；Math.PI；
* **使用static修饰方法：静态方法** 
  * 随着类的加载而加载，可以通过 **“ 类.静态方法 ”** 的方式进行调用
  * 静态方法中，只能调用静态的方法或属性。
  * 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性
* **开发中，如何确定一个属性是否要声明为static的？ ** 
  * 属性的可以被多个对象所共享的，不会随着对象的不同而不同的
  * 类中的常量也常常声明为static
* **开发中，如何确定一个方法是否要声明为static的？** 
  * 操作静态属性的方法，通常设置为static的
  * 工具类中的方法，习惯上声明为static的。比如：Math、Arrays、Collections

***

#### final关键字的使用

1. final可以用来修饰的结构：类、方法、变量
2. final 用来修饰一个类：此类不能被其他类所继承
   * 比如：String类、System类、StringBuffer类
3. final 用来修饰方法：表明此方法不可以被重写
   * 比如：Object类中的getClass()
4. final 用来修饰变量：此时的“变量”就称为是一个常量
   * final修饰属性：可以考虑复制的位置有：显式初始化、代码块中初始化、构造器中初始化
   * final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参，一旦赋值以后，就只能在方法内使用此形参，但是不能重新赋值。
5. static final 用来修饰属性：全局常量
问：比较API两种创建线程的方式（方式一：继承Thread类，实现run（）方法，方式二：实现Runnable的run（）接口）
开发中，优先选择实现Runnable接口的方式
原因：1.实现的方式没有类的单继承的局限性
          2.实现的方式更适合来处理多个线程共享数据的情况
联系：Thread类也实现了Runnable的接口 public class Thread implements Runnable
相同点：两种方式都需要重写run（）方法，将线程要执行的逻辑声明在run（）方法中。

JDK中用Thread.State类定义了线程的几种状态
    要想实现多线程，必须在主线程中创建新的线程对象，Java语言使用Thread类及其子类的对象来表示线程，
在它的一个完整的生命周期中通常要经历如下五种状态：
    新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态
    就绪：处于新建状态的线程被start（）后，将进入线程队列等待CPU时间片，此时它已经具备了运行的条件，只是没分配到CPU资源
    运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run()方法定义了线程的操作和功能
    阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态
    死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束。

                                                                                   线程的生命周期

                            notify()/notifyALl()      ----------------- [阻塞]< ---------------   join()
                                       sleep()时间到    I                                                             I  sleep(long time)
                                        join（）结束    I                                                             I  等待同步锁
               		获取同步锁               I			             I wait()
			               V			             I 
          [新建]      ---调用start（）-->    [就绪]       ----获取CPU的执行权---->      [运行]    ----执行完run()/调用线程stop();-------->    [死亡]
                                                                         <--失去cpu执行权或yield()                        出现Error/Exception且没有处理

线程的同步（解决线程安全问题）
问题的提出：
	多个线程执行的不确定性引起执行结果的不稳定
	多个线程对账本的共享，会造成操作的不完整，会破坏数据

线程死锁问题：
死锁：
      不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。
      出现死锁之后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续
解决办法：
      专门的算法、原则
      尽量减少同步资源的定义
      尽量避免嵌套同步






















